<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>UnDoku</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
/* ====== STYLES ====== */
:root{
  --bg:#0f1116; --panel:#151823; --ink:#e6edf3; --muted:#9aa4b2; --accent:#6aa6ff;
  --good:#38d39f; --bad:#ff5c7a; --warn:#ffd056; --grid:#2a2f3d;
  --given:#9bd4ff; --user:#e6edf3; --hl:#2a3348;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:linear-gradient(180deg,#0e121a 0%, #0b0e15 100%);
  color:var(--ink); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
  display:flex; flex-direction:column; align-items:center; gap:16px; padding:20px;
}
h1{font-size:18px; margin:0; color:#dbe7ff; letter-spacing:.2px}
.app{width:min(980px,94vw); display:grid; grid-template-columns:1fr 320px; gap:16px;}
.left,.right{
  background:var(--panel); border:1px solid #22283a; border-radius:12px;
  padding:14px; box-shadow:0 8px 24px rgba(0,0,0,.35);
}
.controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;}
.controls label{color:var(--muted); font-size:12px}
.controls select,.controls button{
  background:#0f1320; color:var(--ink); border:1px solid #252b3d; border-radius:8px; padding:8px 10px; font-weight:600;
}
.controls .primary{background:#1a2440; border-color:#2d3b64; color:#dbe7ff}
.controls .danger{background:#2b1620; border-color:#523040; color:#ffd1d9}
.controls .ghost{background:#0e1220}
.status{
  background:#0e1322; border:1px dashed #27304d; color:#cfe1ff;
  border-radius:10px; padding:10px 12px; margin-top:8px; min-height:38px;
}
.grid{
  --N:6;
  display:grid;
  grid-template-columns:repeat(var(--N),1fr);
  grid-template-rows:repeat(var(--N),1fr);
  aspect-ratio:1/1; border:2px solid var(--grid); border-radius:8px; overflow:hidden;
}
.cell{position:relative; background:#0d1220; border-right:1px solid var(--grid); border-bottom:1px solid var(--grid);
  display:flex; align-items:center; justify-content:center;
  font-size:clamp(16px,4.2vw,28px); user-select:none; cursor:pointer; color:var(--user);}
.cell.given{color:var(--given); font-weight:800; background:#0c1527;}
.cell.sel{outline:2px solid var(--accent); outline-offset:-2px; z-index:1;}
.cell.hl{background:#16233d;} .cell.bad{background:#3a1b22;}
/* Main value */
.val{position:relative; z-index:2;}
/* Pencilmarks layer */
.notes{
  position:absolute; inset:4px; display:grid; grid-template-columns:repeat(3,1fr);
  gap:1px; align-content:center; justify-items:center; font-size:10px; line-height:1; color:var(--muted);
  pointer-events:none; z-index:1;
}
.note{opacity:.9;}
.note.hidden{visibility:hidden;}
/* Clues: directional arrows and sums */
.clues{position:absolute; inset:3px; pointer-events:none; font-size:10px; color:#a7b7d8;}
.clue{
  position:absolute; padding:2px 4px; border-radius:6px;
  background:#0b1222; border:1px solid #233157; opacity:.97; color:#cfe1ff; display:flex; gap:4px; align-items:center;
}
.clue .arr{font-weight:900; opacity:.95;}
/* Placement by direction */
.clue.dir-u{top:3px; left:3px;}
.clue.dir-d{bottom:3px; right:3px;}
.clue.dir-l{left:3px; bottom:3px;}
.clue.dir-r{right:3px; bottom:3px;}
.clue.dir-ul{top:3px; left:3px;}
.clue.dir-ur{top:3px; right:3px;}
.clue.dir-dl{bottom:3px; left:3px;}
.clue.dir-dr{bottom:3px; right:3px;}
.grid.hide-clues .clues{display:none;}
.pad{display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:8px;}
.key{background:#0e1426; border:1px solid #263154; border-radius:10px;
  padding:10px; text-align:center; font-weight:700; cursor:pointer; color:#cfe1ff;
  transition:transform .05s ease, background .15s ease, border .15s ease;}
.key:hover{background:#142043; border-color:#35509a;}
.key:active{transform:translateY(1px);}
.key.clear{grid-column:span 2; background:#1e1521; border-color:#3b2742; color:#ffd8e1;}
.key.clear:hover{background:#2a1b2f;}
.legend{display:flex; gap:10px; color:#b7c4de; font-size:12px; margin-top:10px; flex-wrap:wrap;}
.dot{width:10px; height:10px; display:inline-block; border-radius:50%; margin-right:6px; transform:translateY(1px);}
.d-hl{background:#25365f;} .d-bad{background:#5a2230;}
.d-given{background:#0c1527; border:1px solid #2b3e6c;}
.foot{color:#97a4bd; font-size:12px; text-align:center; opacity:.85;}
.row-sep{height:0; border-top:2px solid #2d3448; margin:10px 0; opacity:.7;}
@media (max-width:880px){.app{grid-template-columns:1fr;}}

/* Right panel tools */
.pad-tools{display:flex; gap:8px; align-items:center; margin-top:6px;}
.toggle{
  background:#0e1426; color:#cfe1ff; border:1px solid #263154; border-radius:8px; padding:8px 10px; font-weight:700; cursor:pointer;
}
.toggle.active{background:#142043; border-color:#35509a; color:#dbe7ff;}

/* --- WIN MODAL --- */
.modal {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.55); display: flex; align-items: center; justify-content: center;
  z-index: 9999;
}
.modal-content {
  background: #0b1222; border: 2px solid var(--accent); border-radius: 10px;
  padding: 20px; color: var(--ink); text-align: center; max-width: 280px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
}
.modal-content h2 { margin-top: 0; color: var(--good); }
.modal-content button {
  margin-top: 12px; padding: 8px 14px; border-radius: 6px;
  background: var(--accent); border: none; color: white; font-weight: 600;
  cursor: pointer;
}
</style>
</head>
<body>
<h1>UnDoku</h1>
<div class="app">
  <div class="left">
    <div class="controls">
      <label for="sizeSel">Size</label>
      <select id="sizeSel">
        <option>4</option><option>5</option><option selected>6</option>
        <option>7</option><option>8</option><option>9</option>
      </select>

      <label for="diffSel">Difficulty</label>
      <select id="diffSel">
        <option>Easy</option><option selected>Medium</option><option>Hard</option>
      </select>

      <button id="newBtn" class="primary">New</button>
      <button id="hintBtn">Hint</button>
      <button id="checkBtn">Check</button>
      <button id="solveBtn" class="danger">Reveal</button>

      <label><input id="clueToggle" type="checkbox" checked style="margin-right:6px">Show clues</label>
    </div>

    <div id="status" class="status">Ready.</div>

    <div id="grid" class="grid" style="--N:6"></div>
  </div>

  <div class="right">
    <div><strong>Keypad</strong></div>
    <div class="pad-tools">
      <button id="pencilToggle" class="toggle" title="Toggle pencilmarks (Shift for temporary)">‚úèÔ∏è Pencil</button>
    </div>
    <div id="kbd" class="pad"></div>
    <div class="row-sep"></div>
    <div class="legend">
      <span><span class="dot d-given"></span>Given</span>
      <span><span class="dot d-hl"></span>Recent</span>
      <span><span class="dot d-bad"></span>Conflict</span>
    </div>
  </div>
</div>

<div class="foot">Built for thoughtful, pen-and-paper style logic. Have fun.</div>

<!-- WIN MODAL HTML -->
<div id="winModal" class="modal" style="display:none;">
  <div class="modal-content">
    <h2>üéâ You Win!</h2>
    <p>Congratulations, you solved it!</p>
    <button onclick="closeWinModal()">OK</button>
  </div>
</div>

<script>
/* ====== State ====== */
let N = 6;
let solution = [];
let puzzle = [];
let values = [];
let given = [];
let dirClue = []; // one clue per cell or null
let selectedIndex = -1;

/* Pencilmarks */
let notes = []; // Array<Set<number>>
let pencilMode = false;

/* ====== Utilities ====== */
function setStatus(msg){ document.getElementById("status").textContent = msg; }
function idx(r,c){ return r*N + c; }
function rc(i){ return [Math.floor(i/N), i%N]; }

const RAND = {
  seed: 123456789,
  next() { // 32-bit LCG
    this.seed = (1664525 * this.seed + 1013904223) >>> 0;
    return this.seed;
  }
};
function rand(){ return (RAND.next() / 4294967296); }
function randInt(lo, hi){ return lo + Math.floor(rand()*(hi-lo+1)); }

function rayCellsFrom(r, c, dr, dc){
  const ray = [];
  let rr = r + dr, cc = c + dc;
  while (rr>=0 && rr<N && cc>=0 && cc<N){
    ray.push(idx(rr,cc));
    rr += dr; cc += dc;
  }
  return ray;
}
function dirMeta(dr, dc){
  if (dr===-1 && dc===0) return {cls:'dir-u', arr:'‚Üë'};
  if (dr===1 && dc===0)  return {cls:'dir-d', arr:'‚Üì'};
  if (dr===0 && dc===-1) return {cls:'dir-l', arr:'‚Üê'};
  if (dr===0 && dc===1)  return {cls:'dir-r', arr:'‚Üí'};
  if (dr===-1 && dc===-1) return {cls:'dir-ul', arr:'‚Üñ'};
  if (dr===-1 && dc===1)  return {cls:'dir-ur', arr:'‚Üó'};
  if (dr===1 && dc===-1)  return {cls:'dir-dl', arr:'‚Üô'};
  if (dr===1 && dc===1)   return {cls:'dir-dr', arr:'‚Üò'};
  return {cls:'dir-r', arr:'‚Üí'};
}

/* ====== Rendering ====== */
function renderGrid(){
  const grid = document.getElementById("grid");
  grid.style.setProperty('--N', N);
  grid.innerHTML = '';
  for (let i=0;i<N*N;i++){
    const cell = document.createElement('div');
    cell.className = 'cell' + (given[i] ? ' given' : '');
    cell.dataset.i = i;

    const val = document.createElement('div');
    val.className = 'val';
    val.textContent = values[i] ? String(values[i]) : '';

    const notesEl = document.createElement('div');
    notesEl.className = 'notes';
    // Create N note slots (arranged in 3 columns)
    for (let d=1; d<=N; d++){
      const sp = document.createElement('span');
      sp.className = 'note';
      sp.dataset.n = d;
      sp.textContent = d;
      notesEl.appendChild(sp);
    }

    const cluesEl = document.createElement('div');
    cluesEl.className = 'clues';

    // render one optional directional clue
    const cl = dirClue[i];
    if (cl){
      const meta = dirMeta(cl.dr, cl.dc);
      const clBox = document.createElement('div');
      clBox.className = 'clue ' + meta.cls;
      const arr = document.createElement('span');
      arr.className = 'arr';
      arr.textContent = meta.arr;
      const sum = document.createElement('span');
      sum.textContent = cl.sum;
      clBox.appendChild(arr);
      clBox.appendChild(sum);
      cluesEl.appendChild(clBox);
    }

    cell.appendChild(val);
    cell.appendChild(notesEl);
    cell.appendChild(cluesEl);
    grid.appendChild(cell);

    updateNotesRender(i);
  }
  // reapply selection if any
  if (selectedIndex >= 0 && selectedIndex < N*N){
    document.getElementById("grid").children[selectedIndex].classList.add('sel');
  }
}

function updateCell(i){
  const grid = document.getElementById("grid");
  const cell = grid.children[i];
  if (!cell) return;
  const valEl = cell.querySelector(".val");
  valEl.textContent = values[i] ? String(values[i]) : "";
  updateNotesRender(i);
}

function updateNotesRender(i){
  const grid = document.getElementById("grid");
  const cell = grid.children[i];
  if (!cell) return;
  const notesEl = cell.querySelector(".notes");
  const hasVal = values[i] > 0;
  // Hide notes visually when a main value is present (keeps data)
  notesEl.style.display = hasVal ? "none" : "grid";
  const set = notes[i];
  notesEl.querySelectorAll(".note").forEach(sp => {
    const d = parseInt(sp.dataset.n,10);
    if (d > N){ sp.classList.add("hidden"); return; }
    sp.classList.toggle("hidden", !set.has(d));
  });
}

function selectCell(i){
  const grid = document.getElementById("grid");
  if (selectedIndex>=0 && grid.children[selectedIndex]){
    grid.children[selectedIndex].classList.remove('sel');
  }
  selectedIndex = i;
  if (i>=0 && grid.children[i]) grid.children[i].classList.add('sel');
}

function moveSel(dr, dc){
  if (selectedIndex < 0){ selectCell(0); return; }
  let [r,c] = rc(selectedIndex);
  r = Math.max(0, Math.min(N-1, r + dr));
  c = Math.max(0, Math.min(N-1, c + dc));
  selectCell(idx(r,c));
}

/* ====== Pencilmarks ====== */
function ensureNotes(){
  if (!notes || notes.length !== N*N){
    notes = Array.from({length:N*N}, ()=>new Set());
  }
}

function toggleNote(d){
  if (selectedIndex < 0) { setStatus("Select a cell first."); return; }
  if (given[selectedIndex]) { setStatus("That cell is a given."); return; }
  ensureNotes();
  const set = notes[selectedIndex];
  if (set.has(d)) set.delete(d); else set.add(d);
  updateNotesRender(selectedIndex);
  setStatus("Pencil " + d + (set.has(d) ? " added." : " removed."));
}

function clearNotesAt(i){
  ensureNotes();
  notes[i].clear();
  updateNotesRender(i);
}

function eliminateFromPeers(i, d){
  const [r,c] = rc(i);
  // row
  for (let cc=0; cc<N; cc++){
    const j = idx(r,cc);
    if (j===i) continue;
    if (notes[j] && notes[j].delete) { notes[j].delete(d); updateNotesRender(j); }
  }
  // column
  for (let rr=0; rr<N; rr++){
    const j = idx(rr,c);
    if (j===i) continue;
    if (notes[j] && notes[j].delete) { notes[j].delete(d); updateNotesRender(j); }
  }
}

/* ====== Input ====== */
function placeDigit(d){
  if (selectedIndex < 0){
    setStatus("Select a cell first.");
    return;
  }
  if (given[selectedIndex]){
    setStatus("That cell is a given.");
    return;
  }
  values[selectedIndex] = d > 0 ? d : 0;
  updateCell(selectedIndex);
  // Clear notes in this cell, and optionally eliminate from peers when placing a digit
  if (d > 0){
    clearNotesAt(selectedIndex);
    eliminateFromPeers(selectedIndex, d);
  }

  if (checkWin()){
    showWinModal();
  }
}

function bindGridInteractions(){
  const grid = document.getElementById("grid");
  grid.addEventListener("click", (e) => {
    const cell = e.target.closest(".cell");
    if (!cell || !grid.contains(cell)) return;
    const i = parseInt(cell.dataset.i, 10);
    if (!isNaN(i)) selectCell(i);
  });
  document.addEventListener("keydown", (e) => {
    // Arrow keys move selection
    if (e.key === "ArrowLeft") { e.preventDefault(); moveSel(0,-1); return; }
    if (e.key === "ArrowRight"){ e.preventDefault(); moveSel(0,1); return; }
    if (e.key === "ArrowUp")   { e.preventDefault(); moveSel(-1,0); return; }
    if (e.key === "ArrowDown") { e.preventDefault(); moveSel(1,0); return; }

    // Digits
    if (e.key >= "1" && e.key <= "9"){
      const d = parseInt(e.key,10);
      if (d<=N){
        if (e.shiftKey || pencilMode) toggleNote(d);
        else placeDigit(d);
      }
      return;
    }

    // Clear / Delete
    if (e.key === "0" || e.key === "Backspace" || e.key === "Delete"){
      if (e.shiftKey || pencilMode){
        if (selectedIndex >= 0) { clearNotesAt(selectedIndex); setStatus("Pencilmarks cleared."); }
      } else {
        placeDigit(0);
      }
      return;
    }
  });
}

function buildPad(n){
  const pad = document.getElementById("kbd");
  pad.innerHTML = '';
  for (let d=1; d<=n; d++){
    const k = document.createElement('div');
    k.className = 'key';
    k.dataset.d = d;
    k.textContent = d;
    pad.appendChild(k);
  }
  const clr = document.createElement('div');
  clr.className = 'key clear';
  clr.dataset.clear = '1';
  clr.textContent = 'Clear';
  pad.appendChild(clr);
}

function bindPad(){
  const pad = document.getElementById("kbd");
  pad.addEventListener("click", (e) => {
    const key = e.target.closest(".key");
    if (!key || !pad.contains(key)) return;
    if (key.dataset.clear){
      if (pencilMode || e.shiftKey){
        if (selectedIndex >= 0) { clearNotesAt(selectedIndex); setStatus("Pencilmarks cleared."); }
      } else {
        placeDigit(0); setStatus("Cleared.");
      }
      return;
    }
    const d = parseInt(key.dataset.d, 10);
    if (!isNaN(d) && d>=1 && d<=N){
      if (pencilMode || e.shiftKey){ toggleNote(d); }
      else { placeDigit(d); setStatus("Placed "+d+"."); }
    }
  });

  // Pencil toggle button
  const pbtn = document.getElementById("pencilToggle");
  pbtn.addEventListener("click", () => {
    pencilMode = !pencilMode;
    pbtn.classList.toggle("active", pencilMode);
    pbtn.textContent = pencilMode ? "‚úèÔ∏è Pencil (On)" : "‚úèÔ∏è Pencil";
    setStatus(pencilMode ? "Pencil mode on." : "Pencil mode off.");
  });
}

/* ====== Validation ====== */
function clearMarks(){
  const grid = document.getElementById("grid");
  for (const el of grid.children) el.classList.remove("bad");
}

function validateAndMark(){
  clearMarks();
  let conflicts = 0;
  const grid = document.getElementById("grid");

  // row conflicts
  for (let r=0;r<N;r++){
    const seen = {};
    for (let c=0;c<N;c++){
      const i = idx(r,c), v = values[i];
      if (!v) continue;
      if (seen[v] != null){ grid.children[i].classList.add("bad"); grid.children[seen[v]].classList.add("bad"); conflicts++; }
      else seen[v] = i;
    }
  }
  // column conflicts
  for (let c=0;c<N;c++){
    const seen = {};
    for (let r=0;r<N;r++){
      const i = idx(r,c), v = values[i];
      if (!v) continue;
      if (seen[v] != null){ grid.children[i].classList.add("bad"); grid.children[seen[v]].classList.add("bad"); conflicts++; }
      else seen[v] = i;
    }
  }

  // directional sum checks when complete along ray
  for (let i=0;i<N*N;i++){
    const cl = dirClue[i];
    if (!cl) continue;
    if (!cl.ray) cl.ray = rayCellsFrom(...rc(i), cl.dr, cl.dc);
    const all = cl.ray.every(j => values[j] > 0);
    if (all){
      const s = cl.ray.reduce((a,j)=>a+values[j],0);
      if (s !== cl.sum){ grid.children[i].classList.add("bad"); conflicts++; }
    }
  }
  return conflicts;
}

function checkWin(){
  for (let i=0; i<N*N; i++){
    if (values[i] !== solution[i]) return false;
  }
  return true;
}

/* ====== Puzzle generation ====== */
function genLatinSolution(n){
  // base Latin: (r + c) % n + 1
  const base = Array.from({length:n}, (_,r) =>
    Array.from({length:n}, (_,c) => ((r + c) % n) + 1)
  );

  // random symbol relabel
  const labels = Array.from({length:n}, (_,i)=>i+1);
  for (let i=n-1;i>0;i--){ const j = randInt(0,i); [labels[i],labels[j]]=[labels[j],labels[i]]; }
  // random row/col permutations
  const rows = Array.from({length:n}, (_,i)=>i);
  const cols = Array.from({length:n}, (_,i)=>i);
  for (let i=n-1;i>0;i--){ const j = randInt(0,i); [rows[i],rows[j]]=[rows[j],rows[i]]; }
  for (let i=n-1;i>0;i--){ const j = randInt(0,i); [cols[i],cols[j]]=[cols[j],cols[i]]; }

  const sol = Array(n*n).fill(0);
  for (let r=0;r<n;r++){
    for (let c=0;c<n;c++){
      const v = base[rows[r]][cols[c]];
      sol[idx(r,c)] = labels[v-1];
    }
  }
  return sol;
}

function pickDirectionsForClues(){
  // 8 directions
  const dirs = [
    [-1,0], [1,0], [0,-1], [0,1],
    [-1,-1], [-1,1], [1,-1], [1,1]
  ];
  // Prefer straight for clarity
  const weighted = [[-1,0],[1,0],[0,-1],[0,1], [-1,-1],[-1,1],[1,-1],[1,1], [0,1],[1,0]]; // a bit more weight on straight
  function sampleDir(){ const k = randInt(0, weighted.length-1); return weighted[k]; }
  return {dirs, sampleDir};
}

function makeDirectionalClues(sol, difficulty){
  const { sampleDir } = pickDirectionsForClues();
  const clueProb = (function(){
    if (difficulty === 'Easy') return 0.35;
    if (difficulty === 'Hard') return 0.18;
    return 0.25; // Medium
  })();

  const clues = Array(N*N).fill(null);
  for (let i=0;i<N*N;i++){
    const [r,c] = rc(i);
    const [dr,dc] = sampleDir();
    const ray = rayCellsFrom(r,c,dr,dc);
    if (ray.length === 0) continue; // skip border pointing outwards
    if (rand() <= clueProb){
      const sum = ray.reduce((a,j)=>a + sol[j], 0);
      clues[i] = { dr, dc, sum, ray };
    }
  }
  return clues;
}

function generatePuzzle(difficulty){
  solution = genLatinSolution(N);
  dirClue = makeDirectionalClues(solution, difficulty);

  // seed givens count by difficulty
  const targetGivens = (function(){
    if (difficulty === 'Easy') return Math.max(2, Math.floor(0.35*N*N));
    if (difficulty === 'Hard') return Math.max(1, Math.floor(0.15*N*N));
    return Math.max(1, Math.floor(0.25*N*N));
  })();

  given = Array(N*N).fill(false);
  values = Array(N*N).fill(0);
  puzzle = Array(N*N).fill(0);
  notes = Array.from({length:N*N}, ()=>new Set());

  // choose random cells to reveal
  const cells = Array.from({length:N*N}, (_,i)=>i);
  for (let i=cells.length-1;i>0;i--){ const j = randInt(0,i); [cells[i],cells[j]]=[cells[j],cells[i]]; }
  for (let k=0; k<targetGivens && k<cells.length; k++){
    const i = cells[k];
    puzzle[i] = solution[i];
    values[i] = solution[i];
    given[i] = true;
    // ensure no notes shown for givens
    notes[i].clear();
  }
}

function solveCount(startPuzzle, clues, limit){
  // Precompute rays by anchor
  const rays = clues.map((cl, i) => {
    if (!cl) return null;
    if (!cl.ray) cl.ray = rayCellsFrom(...rc(i), cl.dr, cl.dc);
    return cl.ray;
  });

  const board = startPuzzle.slice();
  let count = 0;

  // row/col trackers
  const rowHas = Array.from({length:N}, ()=>Array(N+1).fill(false));
  const colHas = Array.from({length:N}, ()=>Array(N+1).fill(false));
  for (let i=0;i<N*N;i++){
    const v = board[i];
    if (v){
      const [r,c] = rc(i);
      rowHas[r][v] = true;
      colHas[c][v] = true;
    }
  }

  function consistentPlace(i, v){
    const [r,c] = rc(i);
    if (rowHas[r][v] || colHas[c][v]) return false;

    // directional pruning per anchor cells that include this i
    for (let k=0;k<N*N;k++){
      const ray = rays[k];
      if (!ray) continue;
      if (ray.indexOf(i) === -1) continue;

      let partial = 0, unknown = 0;
      for (const j of ray){
        const vv = (j===i) ? v : board[j];
        if (vv){ partial += vv; }
        else unknown++;
      }
      const target = clues[k].sum;
      const maxRemain = unknown * N;
      const minRemain = unknown * 1;
      if (partial > target) return false;
      if (partial + maxRemain < target) return false;
      if (unknown === 0 && partial !== target) return false;
    }

    return true;
  }

  const empties = [];
  for (let i=0;i<N*N;i++) if (!board[i]) empties.push(i);

  function candidates(i){
    const [r,c] = rc(i);
    const cand = [];
    for (let v=1; v<=N; v++){
      if (!rowHas[r][v] && !colHas[c][v]){
        cand.push(v);
      }
    }
    for (let i=cand.length-1;i>0;i--){ const j = randInt(0,i); [cand[i],cand[j]]=[cand[j],cand[i]]; }
    return cand;
  }

  empties.sort((a,b)=>candidates(a).length - candidates(b).length);

  function dfs(pos){
    if (count >= limit) return;
    if (pos === empties.length){ count++; return; }
    const i = empties[pos];
    const [r,c] = rc(i);
    const cand = candidates(i);
    for (const v of cand){
      if (!consistentPlace(i, v)) continue;
      board[i] = v;
      rowHas[r][v] = true;
      colHas[c][v] = true;
      dfs(pos+1);
      rowHas[r][v] = false;
      colHas[c][v] = false;
      board[i] = 0;
      if (count >= limit) return;
    }
  }

  dfs(0);
  return count;
}

/* ====== Controls ====== */
function bindControls(){
  const sizeSel = document.getElementById("sizeSel");
  const diffSel = document.getElementById("diffSel");
  const newBtn  = document.getElementById("newBtn");
  const hintBtn = document.getElementById("hintBtn");
  const checkBtn= document.getElementById("checkBtn");
  const solveBtn= document.getElementById("solveBtn");
  const clueTog = document.getElementById("clueToggle");
  const grid = document.getElementById("grid");

  sizeSel.addEventListener("change", () => { N = parseInt(sizeSel.value, 10); buildPad(N); newPuzzle(); });
  diffSel.addEventListener("change", () => setStatus("Difficulty: " + diffSel.value));
  newBtn.addEventListener("click", newPuzzle);

  hintBtn.addEventListener("click", () => {
    const empties = [];
    for (let i=0;i<N*N;i++) if (!given[i] && values[i]===0) empties.push(i);
    if (!empties.length){ setStatus("No empty cells to hint."); return; }
    const i = empties[Math.floor(rand()*empties.length)];
    values[i] = solution[i];
    const cell = document.getElementById("grid").children[i];
    if (cell){
      const valEl = cell.querySelector(".val");
      if (valEl) valEl.textContent = String(values[i]);
      cell.classList.add("hl");
      setTimeout(()=>cell.classList.remove("hl"), 450);
    }
    // clear notes in this cell and eliminate from peers
    clearNotesAt(i);
    eliminateFromPeers(i, values[i]);

    setStatus("Filled a safe digit.");
    if (checkWin()) showWinModal();
  });

  checkBtn.addEventListener("click", () => {
    const conflicts = validateAndMark();
    if (conflicts === 0 && checkWin()){
      showWinModal();
    } else {
      setStatus(conflicts ? conflicts + " conflict" + (conflicts>1?"s":"") + " highlighted." : "No conflicts detected.");
    }
  });

  solveBtn.addEventListener("click", () => {
    values = solution.slice();
    // wipe all notes on reveal for clarity
    notes = Array.from({length:N*N}, ()=>new Set());
    renderGrid();
    setStatus("Solution revealed.");
  });
  clueTog.addEventListener("change", () => grid.classList.toggle("hide-clues", !clueTog.checked));
}

/* ====== Lifecycle ====== */
function newPuzzle(){
  const sizeSel = document.getElementById("sizeSel");
  const diffSel = document.getElementById("diffSel");
  N = parseInt(sizeSel.value, 10) || 6;
  RAND.seed = (Date.now() % 2147483647);
  setStatus("Generating "+N+"√ó"+N+" ("+diffSel.value+")‚Ä¶");

  let attempts = 0;
  while (attempts < 6){
    generatePuzzle(diffSel.value);
    const count = solveCount(puzzle, dirClue, 2);
    if (count === 1) break;
    attempts++;
  }

  values = puzzle.slice();
  renderGrid();
  buildPad(N);
  setStatus("Puzzle ready.");
}

function init(){
  const sizeSel = document.getElementById("sizeSel");
  N = parseInt(sizeSel.value, 10) || 6;
  buildPad(N);
  bindControls();
  bindGridInteractions();
  bindPad();
  newPuzzle();
  const clueTog = document.getElementById("clueToggle");
  document.getElementById("grid").classList.toggle("hide-clues", !clueTog.checked);
  // initialize pencil button state
  document.getElementById("pencilToggle").classList.toggle("active", pencilMode);
}

/* --- MODAL FUNCTIONS --- */
function showWinModal(){ document.getElementById("winModal").style.display = "flex"; }
function closeWinModal(){ document.getElementById("winModal").style.display = "none"; }

window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>